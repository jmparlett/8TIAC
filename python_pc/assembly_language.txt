___________Instructions / assembly language______________
all Instructions are 8 bit codes. Generally the first 4 bits denote the instruction
and the last 4 denote the target registers

The first bit denotes an ALU or Non ALU instruction
    MSB = 1 denotes ALU:
        next 3 bits are the opcodes
        1000 rarb = ADD RA,RB (Can be read as "Add the contents of regA to regB. This follows for all instructions)
        1001 rarb = SHL RA,RB
        1010 rarb = SHR RA,RB
        1011 rarb = NOT RA,RB
        1100 rarb = AND RA,RB
        1101 rarb = OR  RA,RB
        1110 rarb = XOR RA,RB
        1111 rarb = CMP RA,RB
    MSB = 0 denotes non ALU:
        0000 rarb = LD RA,RB      (Load reg B from address in reg A)
        0001 rarb = ST RA,RB      (Store contents of register B to address in Register A)
        0010 00rb = DATA RB, addr (Load these 8 bits into register B)
        0011 00rb = JMPR          (jump to mem address in regB)
        0100 0000 = JMP RB        (jump to mem address in next byte)
        0100 0000 = JMP           (jump to mem address in regB)
        0101 caez = JCAEZ Addr    (jump if tested flag is on)
        0110 0000 = CLF           (Clear flags)

Last 4 bits denote register A and B:
    00 = Reg0
    01 = Reg1
    10 = Reg2
    11 = Reg3

Standard input (stdIn)
stdIn is a list in the CLU. The first item in this list is removed and input to R3, if ,R3 is empty (all zeros).
This allows you to handle input by reading from R3. Once input has been used you may zero R3 using XOR.
This will allow you to handle the next input.


Bootstrap program
R0 = index #having an initial value of 4
R1 = 1     #after loading from first location in program
R2 = 0     #will be used for comparison
R3 = content

CMP R3, R2      #if register 3 is still zero after being XOR'ed then there are no new instructions to be loaded
JMP E           #Jump if equal
Addr            #Jump address (Location 9)
ST R3, R0       #By default stdIn is loaded to R3 this stores a 1 to mem location 9
LD R2, R0       #The intent of this line is to load 1 into R2. For this to function the input on stdIn must be 00000001
ADD R1, R0      #increment index by 1
XOR R3,R3       #zero R3 to allow for next input from stdIn
JMPR 00R1       #Jump to mem location 0
#if loop is finished zero registers and jump to beginning of program
XOR R0,R0
XOR R1,R1
JMP             #Jump to address stored in next byte of memory
Addr            #Address of beginning of program (Location 13)



BinaryCode (These Instructions will consume the first 12 addresses in memory)
1111 1011
0101        (need codes for flags)
0000 1001
0001 1100
0000 1000
1000 0100
1110 1111
0011 0001
1110 0000
1110 0101

