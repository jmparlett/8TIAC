___________Instructions / assembly language______________
all Instructions are 8 bit codes. Generally the first 4 bits denote the instruction
and the last 4 denote the target registers

The first bit denotes an ALU or Non ALU instruction
    MSB = 1 denotes ALU:
        next 3 bits are the opcodes
        1000 RARB = ADD RA,RB (Can be read as "Add the contents of regA to regB. This follows for all instructions)
        1001 RARB = SHL RA,RB  (Shift RA left and write output to RB)
        1010 RARB = SHR RA,RB  (Shift RA right and write output to RB)
        1011 RARB = NOT RA,RB  (Write the Inverse byte of RA to RB)
        1100 RARB = AND RA,RB  (AND RA and RB and write output to RB)
        1101 RARB = OR  RA,RB  (OR RA and RB and write output to RB)
        1110 RARB = XOR RA,RB  (XOR RA and RB and put answer in RB)
        1111 RARB = CMP RA,RB  (Compare RA and RB)
    MSB = 0 denotes non ALU:
        0000 RARB = LD RA,RB      (Load reg B from address in reg A)
        0001 RARB = ST RA,RB      (Store contents of register B to address in Register A)
        0010 00RB = DATA 00,RB    (Load the contents of the next memory byte into RB)
        0011 00RB = JMPR 00,RB    (jump to mem address in RB)
        0100 0000 = JMP 00,00     (Jump to mem address in next byte of memory)
        0101 CAEZ = JCAEZ Addr    (jump if tested flag is on)
             1000 = JC            (Jump if carry)
             0100 = JA            (Jump if A larger)
             0010 = JE            (Jump if Equal)
             0001 = JZ            (Jump if Zero)
        0110 0000 = CLF           (Clear flags)

Last 4 bits denote register A and B:
    00 = Reg0
    01 = Reg1
    10 = Reg2
    11 = Reg3

Standard input (stdIn)
stdIn is a list in the CLU. The first item in this list is removed and input to R3, if ,R3 is empty (all zeros).
This allows you to handle input by reading from R3. Once input has been used you may zero R3 using XOR.
This will allow you to handle the next input.


Bootstrap program  (This program is used internaly and is executed by the "Read Program to Memory Button")
These values will be set manually instead of through calls to the 8TIAC
A one will be appended to the beginning of the instruction list to be loaded to facilitate this program
R0 = index #having an initial value of 14
R1 = 1     #after loading from first location in program
R2 = 0     #will be used for comparison
R3 = content

1.  CMP  R3,R2      #if register 3 is still zero after being XOR'ed then there are no new instructions to be loaded
2.  JMP  JE         #Jump if equal
3.  Addr            #Jump address (Location 9)
4.  ST   R3,R0      #By default stdIn is loaded to R3 this stores a 1 to mem location 9
5.  LD   R2,R0      #The intent of this line is to load 1 into R2. For this to function the input on stdIn must be 00000001
6.  ADD  R1,R0      #increment index by 1
7.  XOR  R3,R3      #zero R3 to allow for next input from stdIn
8.  JMPR 00R1       #Jump to mem location 0
#if loop is finished zero registers and jump to beginning of program
9.  XOR  R0,R0       
10. XOR  R1,R1
11. CLF
12. JMPR            #Jump to address stored in next byte of memory
13. Addr            #Address of beginning of program (Location 14)



BinaryCode (These Instructions will consume the first 13 addresses in memory)
11111110
01010010
00001001
00011100
00001000
10000100
11101111
00110001
11100000
11100101
01100000
01000000
00001110
